<!doctype html>

<!--[if lt IE 7 ]> <html class="ie ie6 no-js" lang="en"> <![endif]-->
<!--[if IE 7 ]>    <html class="ie ie7 no-js" lang="en"> <![endif]-->
<!--[if IE 8 ]>    <html class="ie ie8 no-js" lang="en"> <![endif]-->
<!--[if IE 9 ]>    <html class="ie ie9 no-js" lang="en"> <![endif]-->
<!--[if gt IE 9]><!--><html class="no-js" lang="en"><!--<![endif]-->
<!-- the "no-js" class is for Modernizr. -->

<head id="frostbite" data-template-set="html5-reset">

	<meta charset="utf-8">
	
	<!-- Always force latest IE rendering engine (even in intranet) & Chrome Frame -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Scripting - basics</title>
	
	<meta name="title" content="">
	<meta name="description" content="">
	<!-- Google will often use this as its description of your page/site. Make it good. -->
	
	<meta name="google-site-verification" content="">
	<!-- Speaking of Google, don't forget to set your site up: http://google.com/webmasters -->
	
	<meta name="author" content="Your Name Here">
	<meta name="Copyright" content="Copyright Your Name Here 2011. All Rights Reserved.">

	<!-- Dublin Core Metadata : http://dublincore.org/ -->
	<meta name="DC.title" content="Frostbite">
	<meta name="DC.subject" content="Dragonrealms MUD Frontend">
	<meta name="DC.creator" content="">
	
	<!--  Mobile Viewport Fix
	j.mp/mobileviewport & davidbcalhoun.com/2010/viewport-metatag 
	device-width : Occupy full width of the screen in its current orientation
	initial-scale = 1.0 retains dimensions instead of zooming out if page height > device height
	maximum-scale = 1.0 retains dimensions instead of zooming in if page width < device width
	-->
	<!-- Uncomment to use; use thoughtfully!
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
	-->

	<link rel="shortcut icon" href="img/favicon.png">
	<!-- This is the traditional favicon.
		 - size: 16x16 or 32x32
		 - transparency is OK
		 - see wikipedia for info on browser support: http://mky.be/favicon/ -->
		 
	<link rel="apple-touch-icon" href="img/favicon.png">
	<!-- The is the icon for iOS's Web Clip.
		 - size: 57x57 for older iPhones, 72x72 for iPads, 114x114 for iPhone4's retina display (IMHO, just go ahead and use the biggest one)
		 - To prevent iOS from applying its styles to the icon name it thusly: apple-touch-icon-precomposed.png
		 - Transparency is not recommended (iOS will put a black BG behind the icon) -->
	
	<!-- CSS: screen, mobile & print are all in the same file -->
	<link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/web.css">
	
	<!-- all our JS is at the bottom of the page, except for Modernizr. -->
	<script src="js/modernizr-1.7.min.js"></script>

    <link rel="stylesheet" href="js/highlight/styles/github.css" />
    <script src="js/highlight/highlight.pack.js "></script>
    <script>hljs.initHighlightingOnLoad();</script>

</head>

<body>

<div class="wrapper">
    <header>
        <hgroup>
            <img src="img/logo.png" /><br/>
            <h1>Frostbite</h1>
            <h2 class="">A MUD client for Dragonrealms</h2>
        </hgroup>
    </header>

    <h2 class="contents_head" id="contents">3.1 Basics</h2>
    <div class="about">
        <p>
            The Frostbite client scripting is based on the Ruby scripting language. Ruby syntax is easy and intuitive
            to use, it supports multi-paradigm programming and it's functions are very powerful. All of which incorporates
            into a very flexible scripting environment. Descriptions for Ruby functions are available in the Ruby
            <a href="http://ruby-doc.org/core-1.9.3/">documentation</a>.
        </p>
        <p>
            On top of Ruby tools, the Frostbite frontend offers it's own set of functions which are more specific to the game
            itself. The API description is available in the <a href="api.html">API</a> section.
        </p><br/>
        <h3>Creating and running scripts</h3>
        <p>
            The Ruby script files are required to be created as <i>".rb"</i> extension files and the script files need to
            be placed into the client <i>"scripts"</i> folder.
        </p>
        <p>
            The scripts can be executed in the client command line by calling the file name with a <i>"."</i> prefix.
            For example, running braid.rb: <i>".braid vine"</i>.
        </p><br/>

        <h3>Stopping scripts</h3>
        <p>
            Once the script is running it can be stopped by pressing the ESC key on the keyboard. In the event of any
            crashes which render the script unable to exit in a normal way, the ESC key has to be pressed once more to
            terminate the script forcefully.
        </p>
        <br/>

        <h3>Parameter descriptions</h3>

        <pre><code>$args # global variable, available everywhere</code></pre>
        <p>Contains the arguments passed on to the script in the command line.</p>

        <pre><code>@match_rt_adjustment = 0 # class scope variable, available in functions</code></pre>
        <p>This is an adjustment parameter which is added to the round time values used by match functions. It enables to regulate
        the wait times and make the script run faster by tightening the value. This is of course in case the script is
        prepared to deal with the possible outcome of running the commands too early.</p>

        <br/>
        <h3>Script structures and blocks</h3>
        <p>
            All the Frostbite API driven scripts can be directed to <i>"finally_do"</i> method at script exit. This includes either aborting the
            script or exiting by natural means. The final block can be avoided by calling Kernel::exit! or Kernel::abort. If the
            <i>"finally_do"</i> function is not defined in the script, no extra action will be taken at the script exit. Finally block is
            useful when you want to perform clean up tasks after running the script.
        </p>

    <pre><code>
    def finally_do {
        put "put my #{$args.first} in my backpack"
    }
    </code></pre>
        <br/>
        <p>
            There are different ways to set up the script flow in Ruby. With some additions to the standard library
            it is possible to create Wizard-like label structures. For labels to work it is required to wrap the label code into
            <i>"labels_start"</i> and <i>"labels_end" markers</i>.
        </p>

    <pre><code>
    labels_start

    label(:study) {
        put "study my compendium"
        match = { :study => ["studying", "You continue to study"],
                  :turn => ["makes sense to you"],
                  :exit => ["study this chart again"] }
        match_wait_goto match
    }

    label(:turn) {
        put "turn my compendium"
        wait
        goto :study
    }

    labels_end
    </code></pre>
        <br/>
        <p>
            The match mechanics can also be executed without labels by calling the <i>"match_wait"</i> function instead.
            This way the keyword (:symbol) for the match will be returned by the function and any further action depends on
            the decision logic that handles those responses.
        </p>

    <pre><code>
    put "go rosewood arch"
    match = { :second => ["The attendant steps in"],
              :continue => ["The Dwarven attendant escorts"] }
    result = match_wait match

    case result
        when :second
        move "go ironwood arch"
    end
    </code></pre>
        <br/>
        <p>
            For avoiding code repetitions, Ruby enables to create functions and loops to keep the script clean from any
            redundant code.
        </p>
    <pre><code>
    def juggle
        put "juggle my " + $args.join(" ")
        wait_for_roundtime
    end

    10.times do
        juggle
    end
    </code></pre>
        <br/>
        <h3>Functions and models</h3>
        <p>
            The standard API functions have mostly been set up to provide Wizard-like scripting style. Different kind of
            approaches might need changes or additions to the core API functionality. The full description of the Frostbite
            core API functions and models can be found from the <a href="api.html">API</a> section.
        </p>
        <br/>
        <h3>Errors in scripting</h3>
        <p>
            Error messages coming from scripts are displayed in the Frostbite client main window. Scripts containing
            any errors in syntax or structure can not be used until they are fixed. The error messages, in most
            cases, point to the errors by the line number in code to make them easier to find.
        </p>
        <p>
            For example, when calling a function which expects a string type but has not been denoted as such by using
            quotes. In Ruby, variables can be created using just alphanumeric characters and underscore. In this case
            the word - hello - will be handled as a variable which has no value assigned, therefore causing an error.
        </p>
    <pre><code>
#script
echo hello

#=>

#error
C:/FrostBite/scripts/hello.rb:1:in `': undefined local variable or method `hello' for main:Object (NameError)
    </code></pre>
        <p>
            Error on line one, undefined local variable. To fix this particular error, the word hello has to be
            enclosed in quotes -- "hello".
        </p>



    <br/>
    <h3>Regular expressions</h3>
    <p>
        The match functions in scripts are based on regular expressions. To use any of the regular expression
        characters as a literal in a match pattern, they have to be escaped by a backslash.
    </p>

<pre><code>
#escaped to match dot characters instead of any single character
:wait => ["\.\.\.wait"]

#case insensitive, bracets are escaped to match bracet characters
:canyon => [/\[North Road, Canyon\]/i]

#not containing any regular expression special characters
:exit => ["study this chart again"]
</code></pre>
    <br/>

    <p>
        Regular expression reference:
    </p>

<pre><code>
[abc] 	#A single character of: a, b or c
[^abc] 	#Any single character except: a, b, or c
[a-z] 	#Any single character in the range a-z
[a-zA-Z] #Any single character in the range a-z or A-Z
^ 	#Start of line
$ 	#End of line
\A 	#Start of string
\z 	#End of string
. 	#Any single character
\s 	#Any whitespace character
\S 	#Any non-whitespace character
\d 	#Any digit
\D 	#Any non-digit
\w 	#Any word character (letter, number, underscore)
\W 	#Any non-word character
\b 	#Any word boundary
(...) 	#Capture everything enclosed
(a|b) 	#a or b
a? 	#Zero or one of a
a* 	#Zero or more of a
a+ 	#One or more of a
a{3} 	#Exactly 3 of a
a{3,} 	#3 or more of a
a{3,6} 	#Between 3 and 6 of a
</code></pre>

    </div>
	<footer>
        <p><small>Github: https://github.com/matoom/frostbite</small></p>
	</footer>
</div>

<!-- here comes the javascript -->
<script src='js/jquery-1.5.1.min.js'></script>

<!-- this is where we put our custom functions -->
<script src="js/functions.js"></script>

<script type="text/javascript">

    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-36611098-1']);
    _gaq.push(['_trackPageview']);

    (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();

</script>

</body>
</html>